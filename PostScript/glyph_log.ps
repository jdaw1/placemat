%!PS

% This version 23:00 Monday 29th November 2021
% Copyright 2021 Julian D. A. Wiseman of www.jdawiseman.com.

% This sofware is licensed under the GNU General Public License v3.0.
% Permissions of this strong copyleft license are conditioned on making available complete source code of
% licensed works and modifications, which include larger works using a licensed work, under the same license.
% Copyright and license notices must be preserved. Contributors provide an express grant of patent rights.

% http://github.com/jdaw1/placemat/blob/main/Documentation/compound_strings_characters.md#unicode



/TrebuchetMS  % Chosen font





/FontName exch def
/PageHeight 841.88976 def   /PageWidth 595.27559 def   /Margin 36 def
/FontSize 12 def   /TabSize FontSize 1.5 mul def
/LineStep FontSize 1.4 mul def
/Xs [ Margin   PageWidth Margin add 3 div   PageWidth 2 mul Margin sub 3 div ] def
() = FontName == () =


/DeBugLevel 65535 def

/ShellSortGaps
[
	% ShellSort is very fast at short arrays, but QuickSort's segregation helps multi-CPU with long arrays.
	% PostScript's max array size usually 65535 (PLRM3, p739, table B.1), but an implementation could allow longer.
	% Included are those up to PostScript's max integer = 2^31 - 1, and commented out are subsequent up to 10^15.
	% From http://en.wikipedia.org/wiki/Shellsort
	% > Gonnet and Baeza-Yates observed that Shellsort makes the fewest comparisons on average when the ratios of successive gaps are
	% > roughly equal to 2.2. This is why their sequence with ratio 2.2 and Tokuda's sequence with ratio 2.25 prove efficient. However,
	% > it is not known why this is so. Sedgewick recommends using gaps which have low greatest common divisors or are pairwise coprime.
	% Here each is closest to previous * Sqrt5 that is coprime to all previous, so ratios tend to ~=2.236. From 51 ratios >2.21568 and <2.24303.
	1 2 5 11 23 51 113 251 563 1259 2813 6289 14063 31439  % Below 2^16
	70297 157189 351487 785947 1757431 3929741 8787169 19648709 43935851 98243549 219679249 491217733 1098396241  % Below 2^31
	% 2456088659 5491981199 12280443293 27459905999 61402216471 137299529999 307011082351 686497649983 1535055411751
	% 3432488249899 7675277058739 17162441249483 38376385293691 85812206247419 191881926468461 429061031237099 959409632342311
] readonly def  % /ShellSortGaps
/ShellSortGapsLength1Sub ShellSortGaps length 1 sub def
% Immediate dependencies: DeBugLevel; ShellSortGaps; ShellSortGapsLength1Sub.
% [ thing thing ... ] {comparison code that takes two things and returns a boolean} ShellSort -
% Sorts array such that for elements i and i+1 the comparison code returns true (or equal).
% E.g.,   [1 2 3 4 5 2. 3. 4. 5. 3 4 5 4. 5. 5] dup {le} ShellSort ==   outputs   [1 2 2.0 3 3 3.0 4 4.0 4 4.0 5 5 5.0 5.0 5]
% Based on http://www.tutorialspoint.com/data_structures_algorithms/shell_sort_algorithm.htm
/ShellSort
{
	//DeBugLevel 25 le {(+ShellSort) OutputToLog} if
	8 dict begin
	/ComparisonCode exch def
	/Things exch def
	/n Things length def
	n 2 ge
	{
		1  1  //ShellSortGapsLength1Sub
		{
			/gapNum exch def
			//ShellSortGaps gapNum get n gt {/gapNum gapNum 1 sub def  exit} if
		} for  % gapNum up

		gapNum -1 0
		{
			//ShellSortGaps exch get /gap exch def
			gap  1  n 1 sub
			{
				/outer exch def
				/valueToInsert Things outer get def
				/inner outer def
				{
					inner gap lt {exit} if
					Things inner gap sub get  valueToInsert  ComparisonCode  {exit} if
					Things  inner  Things inner gap sub get  put
					/inner inner gap sub def
				} loop  % inner
				Things inner valueToInsert put
			} for  % outer
		} for  % gap down
	} if  % n 2 ge
	end
	//DeBugLevel 25 le {(-ShellSort) OutputToLog} if
} bind def  % /ShellSort
currentdict /ShellSortGaps undef
currentdict /ShellSortGapsLength1Subs undef


/Fonts
	[ FontName findfont /CharStrings get {[ 3 1 roll ]} forall ]
	dup {0 get 256 string cvs exch 0 get 256 string cvs ge} ShellSort
def  % /Fonts



<<  /PageSize [PageWidth PageHeight]  >> setpagedevice


/Yadj 0 def
0 setgray
/Y PageHeight Margin sub LineStep 3 mul sub def
FontName FontSize 3 mul selectfont
FontName 256 string cvs dup stringwidth pop PageWidth exch sub 2 div Y moveto show
FontName FontSize selectfont
/Y Y LineStep sub def
[ Fonts length 10 string cvs  ( characters, shown at ) FontSize 10 string cvs (pt) ]
0  1 index  {stringwidth pop add} forall  PageWidth exch sub 2 div  Y moveto {show} forall
[
	(The quick brown fox jumps over the lazy dog 0123456789)
	(THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG)
	(0123456789 !"#$%&'\(\)*+,-./:;<=>?@[\\]^_`{|}~)  % all ASCII characters
	(K47  D78  Ck12  F27  S35  Cr45  W55  SW63  D70  G85  T92  RP97  N00  V03  Qv11)
	(http://github.com/jdaw1/placemat/blob/main/PostScript/glyph_log.ps)
	(http://github.com/jdaw1/placemat/blob/main/Documentation/compound_strings_characters.md#unicode)
]{
	/Y Y LineStep sub def
	dup 0 4 getinterval (http) eq
	{
		FontName FontSize 5 sqrt 1 sub 2 div mul selectfont
		Xs 0 get Xs 1 get add 2 div  Y Yadj add moveto
		/Yadj Yadj FontSize 0.5 mul add def
	}{
		0.9 setgray  //Margin  Y  PageWidth Margin 2 mul sub  1.92  rectfill  0 setgray
		FontName FontSize selectfont
		Xs 0 get  Y  moveto
	} ifelse  % http
	show
} forall
FontName FontSize selectfont
/Y Y LineStep 2 mul sub def
/Ystart Y def
/Any false def
/PageDested false def
/iX 0 def

Fonts
{
	aload pop /GlyphNum exch def  /GlyphName exch def
	/GlyphNameString GlyphName 245 string cvs def
	256 string  0 1 9 {1 index exch 32 put} for  % Spaces
	dup 10 47 put  % "/"
	GlyphNum 1 index cvs pop  % Number
	GlyphNameString 1 index 11 245 getinterval copy length 11 add 0 exch getinterval
	=

	Xs iX get               Y moveto GlyphName glyphshow
	Xs iX get //TabSize add Y moveto GlyphNameString show
	/Any //true def
	/Y Y LineStep sub def

	PageDested not
	{
		GlyphNameString 0 get dup dup dup  65 ge exch 90 le and 3 1 roll  97 ge exch 122 le and  or
		{
			mark /Dest GlyphName   /DEST  pdfmark
			mark /Action /GoTo  /Dest GlyphName  /Title GlyphNameString  /OUT pdfmark
			/PageDested true def
		} if  % A...Z or a...z
	} if  % first on page

	Y //Margin le
	{
		/iX iX 1 add Xs length mod def
		iX 0 eq {showpage   /Any //false def   /PageDested false def  /Ystart //PageHeight //Margin sub //LineStep sub def} if
		/Y Ystart def
	} if  % Y //Margin le
} bind forall  % Fonts
Any {showpage} if
() =

% Bug check
count dup 0 gt
{
	(Problem!) =   (count =           ) exch
	1 index 8 10 getinterval cvs pop = () =
	(+pstack) = pstack (-pstack) =
} {pop (Stack correctly empty.) =} ifelse
